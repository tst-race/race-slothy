#include "race/RaceApp.h"

#include <OpenTracingHelpers.h>

#include <chrono>
#include <optional>
#include <set>
#include <stdexcept>  // std::out_of_range
#include <thread>

#include <PluginStatus.h>
#include "race/ReceivedMessage.h"
#include "race/RaceUtil.h"

RaceApp::RaceApp(IRaceSdkApp &_raceSdk,
                 std::shared_ptr<opentracing::Tracer> _tracer) :
    raceSdk(_raceSdk),
    tracer(_tracer),
    ready(false),
    responseCache(std::make_unique<UserInputResponseCache>(_raceSdk)),
    responseParser(
        std::make_unique<UserInputResponseParser>(_raceSdk.getAppConfig().userResponsesFilePath)) {}

void RaceApp::addMessageToUI(const ClrMsg &) {
    // Do Nothing, this function is just required for passing send messages
    // generated by RaceTestApp to the UI
    // Android should override this implementation
}

void RaceApp::handleReceivedMessage(ClrMsg msg) {
    auto ctx = spanContextFromClrMsg(msg);
    std::shared_ptr<opentracing::Span> span =
        tracer->StartSpan("receiveMessage", {opentracing::FollowsFrom(ctx.get())});

    //rtah::outputMessage(appOutput, ReceivedMessage(msg));

    span->SetTag("source", "racetestapp");
    span->SetTag("file", __FILE__);
    span->SetTag("messageSize", std::to_string(msg.getMsg().size()));
    span->SetTag("messageHash", RaceUtil::getMessageSignature(msg));
    span->SetTag("messageFrom", msg.getFrom());
    span->SetTag("messageTo", msg.getTo());
    span->SetTag("messageTestId", RaceUtil::testIdFromClrMsg(msg));
}

void RaceApp::onMessageStatusChanged(RaceHandle handle, MessageStatus status) {
    printf("RaceApp::onMessageStatusChanged: called with handle: %s status %s\n", std::to_string(handle).c_str(), messageStatusToString(status).c_str());
}

void RaceApp::onSdkStatusChanged(const nlohmann::json &sdkStatus) {
    //rtah::logInfo("onSdkStatusChanged: called");
    //rtah::logDebug("sdkStatus: " + sdkStatus.dump());
    currentSdkStatus = sdkStatus;

    bool newStatus = sdkStatus["network-manager-status"] == "PLUGIN_READY";
    // Only print a message if ready changed
    if (newStatus and not ready) {
        printf("[RACE] App is ready to send.\n");
    } else if (not newStatus and ready) {
        printf("[RACE] App is unready.\n");
    }
    ready = newStatus;

    //rtah::logInfo("onSdkStatusChanged: return");
}

nlohmann::json RaceApp::getSdkStatus() {
    return currentSdkStatus;
}

SdkResponse RaceApp::requestUserInput(RaceHandle handle, const std::string &pluginId,
                                      const std::string &key, const std::string &prompt,
                                      bool cache) {
    //rtah::logDebug("Looking up user response, pluginId: " + pluginId + " key: " + key +
    //               " prompt: " + prompt);
    UserInputResponseParser::UserResponse response;

    bool cachedResponse = false;
    if (cache) {
        try {
            response.response = responseCache->getResponse(pluginId, key);
            response.answered = true;
            cachedResponse = true;
            //rtah::logDebug("Using cached user response: " + response.response);
        } catch (std::out_of_range &) {
            //rtah::logDebug("No cached user response found");
        }
    }

    if (not response.answered) {
        try {
            response = responseParser->getResponse(pluginId, key);
        } catch (std::exception &error) {
            //rtah::logError(std::string(error.what()));
        }
    }

    if (response.delay_ms > 0) {
        //rtah::logDebug("UserInput delaying " + std::to_string(response.delay_ms) +
        //               "ms before responding");
        std::this_thread::sleep_for(std::chrono::milliseconds(response.delay_ms));
    }

    // If we should cache this and didn't get it from the cache initially,
    // cache the response (but only if we actually got an answer)
    if (cache && not cachedResponse && response.answered) {
        if (not responseCache->cacheResponse(pluginId, key, response.response)) {
            //rtah::logError("Unable to cache user input response");
        }
    }

    //rtah::logDebug("UserInput responding, answered: " + std::to_string(response.answered),
    //               ", response: " + response.response);
    return raceSdk.onUserInputReceived(handle, response.answered, response.response);
}

SdkResponse RaceApp::displayInfoToUser(RaceHandle handle, const std::string &data,
                                       RaceEnums::UserDisplayType /*displayType*/) {
    //rtah::logDebug("displayInfoToUser: called with data:  " + data);
    raceSdk.onUserAcknowledgementReceived(handle);
    return SDK_OK;
}

SdkResponse RaceApp::displayBootstrapInfoToUser(RaceHandle handle, const std::string &data,
                                                RaceEnums::UserDisplayType /*displayType*/,
                                                RaceEnums::BootstrapActionType /*actionType*/) {
    //rtah::logDebug("displayBootstrapInfoToUser: called with data:  " + data);
    raceSdk.onUserAcknowledgementReceived(handle);
    return SDK_OK;
}
